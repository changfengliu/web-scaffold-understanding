(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{180:function(s,t,e){"use strict";e.r(t);var a=e(0),r=Object(a.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var s=this,t=s.$createElement,e=s._self._c||t;return e("div",{staticClass:"content"},[e("h1",{attrs:{id:"js-预处理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#js-预处理","aria-hidden":"true"}},[s._v("#")]),s._v(" JS 预处理")]),s._v(" "),e("p",[s._v("早期我们写前端应用，直接把 javascipt 代码，通过工具脚本合并、压缩就上线了。就是说程序猿们所写的代码是直接可以跑在浏览器中的。")]),s._v(" "),e("p",[s._v("后来出现了一些基于 javascipt 的上层语言，如 CoffeeScript，曾经红极一时，用于解决 js 开发中的痛点。这些上层的 DSL 都是用更高阶的语法写代码，然后用相关的编译器生成 js 代码。这种形式带来的改变是，前端开发不再是写完就能运行的了，需要编译了，像一些后端语言一样，先编译再运行。")]),s._v(" "),e("p",[s._v("基于这种编译运行的思路，使得前端的开发效率与开发体验飞速发展。")]),s._v(" "),e("p",[s._v("从 2015 年出现 ES6 之后，javascript 规范每年都会升级一个版本，或多或少地增加一些新的特性。我们知道规范虽然升级了，但各种 js 引擎未必能够及时全部地跟进。怎样让我们能够在规范未普及的情况下，也能使用这些新式语法，并保证浏览器兼容性呢？也是利用了编译运行的思路。用编译器把我们写的前卫语法，转译成兼容性良好的 ES5 语法就好了。")]),s._v(" "),e("p",[s._v("babel 就是一个这样的编译器，它能够让我们使用前沿的语法，开发兼容性良好的应用。更进一步地，我们也可以定义自己的上层 DSL, 然后写 babel 插件转译它。")]),s._v(" "),e("p",[s._v("最近很受欢迎的 typescript, 也是这样的 DSL，利用编译运行的思路，它也提供了对应的编译器，把 ts 代码转义成 js.")]),s._v(" "),e("p",[s._v("综上所述，通过编译技术，使我们能够用各种各样的上层语法编写 js 应用。当然这一切也要归功于 node.js 的发展。")])])}],!1,null,null,null);r.options.__file="js-preprocessor.md";t.default=r.exports}}]);